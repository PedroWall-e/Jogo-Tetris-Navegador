<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <title>Tetris Battle 8-Bit</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap');

        body {
            margin: 0;
            background: #202028;
            color: white;
            font-family: 'Fredoka One', cursive;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow: hidden;
        }

        /* --- LOBBY --- */
        #lobby-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95);
            z-index: 100;
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            transition: opacity 0.3s;
        }

        .settings-box {
            background: #333; padding: 25px; border-radius: 15px;
            border: 2px solid #555; text-align: center; width: 320px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        .input-group { margin-bottom: 15px; text-align: left; }
        label { color: #aaa; font-size: 0.9rem; margin-bottom: 5px; display: block; }
        
        input[type="text"] {
            padding: 12px; border-radius: 8px; border: none;
            width: 100%; box-sizing: border-box; font-family: inherit; font-size: 1.1rem;
            text-align: center; background: #222; color: #fff; border: 2px solid #444;
        }
        input[type="text"]:focus { outline: none; border-color: #ffe600; }

        input[type="range"] { width: 100%; accent-color: #ffe600; }
        
        select { 
            width: 100%; padding: 10px; background: #222; color: white; 
            border: 2px solid #444; border-radius: 8px; font-family: inherit; 
        }

        .btn-ready {
            margin-top: 25px; padding: 15px 50px; border-radius: 50px;
            border: none; font-size: 1.3rem; cursor: pointer; font-family: inherit;
            transition: 0.2s; width: 100%; text-transform: uppercase;
        }
        .not-ready { background: #ff4757; color: white; box-shadow: 0 5px 0 #b71524; }
        .not-ready:active { transform: translateY(4px); box-shadow: none; }
        
        .is-ready { background: #2ed573; color: white; box-shadow: 0 5px 0 #1e8e4a; }
        .is-ready:active { transform: translateY(4px); box-shadow: none; }

        /* --- JOGO --- */
        #game-area {
            display: flex; gap: 20px; margin-top: 60px;
            flex-wrap: wrap; justify-content: center;
            width: 100%; padding-bottom: 20px;
        }

        .player-card {
            background: #151515; padding: 10px; border-radius: 12px;
            border: 3px solid #444; position: relative;
            min-width: 240px; transition: transform 0.2s;
        }
        .player-card.local { border-color: #ffe600; box-shadow: 0 0 25px rgba(255,230,0,0.15); transform: scale(1.02); }
        .player-card.dead canvas { opacity: 0.3; filter: grayscale(100%); }
        .player-card.dead::after {
            content: "GAME OVER"; position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%); font-size: 2rem; color: #ff4757;
            text-shadow: 2px 2px 0 #000; pointer-events: none;
        }

        canvas { background: #000; display: block; margin: 0 auto; border-radius: 4px; }

        .name-tag { font-size: 1.2rem; color: #fff; margin-bottom: 8px; text-shadow: 1px 1px 2px black; text-align: center; }
        .stats-row { 
            display: flex; justify-content: space-between; font-size: 1rem; 
            color: #aaa; margin-top: 8px; padding: 0 5px; 
        }
        .win-count { color: #ffe600; font-weight: bold; }

        /* --- HUD --- */
        #hud {
            position: absolute; top: 0; width: 100%; padding: 15px 30px;
            display: flex; justify-content: space-between; background: rgba(0,0,0,0.6);
            backdrop-filter: blur(5px); z-index: 50; box-sizing: border-box;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .hud-btn {
            background: #444; color: white; border: none; padding: 10px 20px;
            border-radius: 8px; cursor: pointer; font-family: inherit; font-size: 0.9rem;
            transition: background 0.2s;
        }
        .hud-btn:hover { background: #666; }
        .btn-stop { background: #d32f2f; }
        .btn-stop:hover { background: #b71c1c; }

        /* --- RANKING --- */
        #ranking-screen {
            position: fixed; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: #202028;
            padding: 40px; border-radius: 20px;
            border: 4px solid #ffe600; box-shadow: 0 0 50px rgba(0,0,0,0.8);
            text-align: center; display: none; z-index: 200;
            min-width: 450px;
        }
        
        table { width: 100%; border-collapse: collapse; margin: 20px 0; color: white; }
        th { text-align: left; border-bottom: 2px solid #555; padding: 10px; color: #ffe600; }
        td { text-align: left; padding: 12px 10px; border-bottom: 1px solid #333; }
        
        .rank-1 { color: #ffe600; font-size: 1.3rem; }
        .rank-2 { color: #c0c0c0; }
        .rank-3 { color: #cd7f32; }

        #connection-status {
            position: fixed; top: 60px; right: 20px; padding: 8px 15px;
            border-radius: 20px; font-size: 0.85rem; z-index: 60;
            background: #333; border: 2px solid #555;
        }
        .status-connected { border-color: #2ed573; color: #2ed573; }
        .status-disconnected { border-color: #ff4757; color: #ff4757; }

    </style>
</head>
<body>

    <div id="lobby-screen">
        <h1 style="font-size: 3.5rem; color: #ffe600; margin-bottom: 20px; text-shadow: 4px 4px 0 #d32f2f;">TETRIS BATTLE</h1>
        
        <div class="settings-box">
            <div class="input-group">
                <label>Seu Nome</label>
                <input type="text" id="inp-name" placeholder="Digite seu Nickname" maxlength="10">
            </div>

            <div class="input-group">
                <label>Velocidade: <span id="disp-speed" style="color:#fff">1</span></label>
                <input type="range" id="inp-speed" min="1" max="20" value="1" oninput="emitSettings()">
            </div>

            <div class="input-group">
                <label>Modo de Jogo</label>
                <select id="inp-wins" onchange="emitSettings()">
                    <option value="1">Morte S√∫bita (1 Vit√≥ria)</option>
                    <option value="3" selected>Melhor de 3</option>
                    <option value="5">Melhor de 5</option>
                </select>
            </div>
            
            <button id="btn-ready" class="btn-ready not-ready" onclick="toggleReady()">N√ÉO ESTOU PRONTO</button>
        </div>

        <div id="lobby-status" style="margin-top:20px; color:#aaa; font-size: 1.1rem;">Conectando ao servidor...</div>
    </div>

    <div id="connection-status" class="status-disconnected">‚óè Desconectado</div>

    <div id="hud">
        <button class="hud-btn" id="btn-music" onclick="toggleMusic()">üîá M√∫sica: OFF</button>
        <button class="hud-btn btn-stop" id="btn-stop" style="display:none;" onclick="requestReset()">‚èπ PARAR PARTIDA</button>
    </div>

    <div id="game-area"></div>

    <div id="ranking-screen">
        <h2 style="color:#ffe600; font-size:3rem; margin:0; text-shadow: 2px 2px 0 #000;">FIM DE JOGO</h2>
        <table>
            <thead>
                <tr>
                    <th>#</th>
                    <th>Nome</th>
                    <th>Vit√≥rias</th>
                    <th>Pontos</th>
                </tr>
            </thead>
            <tbody id="ranking-body"></tbody>
        </table>
        <button class="btn-ready is-ready" onclick="requestReset()">VOLTAR AO LOBBY</button>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        // ===================================
        // GERENCIADOR DE ESTADO GLOBAL
        // ===================================
        const GameState = {
            socket: null,
            isConnected: false,
            isGameRunning: false,
            isLocalReady: false,
            isDead: false,
            localPlayerId: null,
            localName: "",
            dropInterval: 1000,
            settings: { speed: 1, winLimit: 3 },
            players: {},
            localGame: null,
            opponents: {},
            lastEmitTime: 0,
            emitThrottle: 50 // ms
        };

        // ===================================
        // SISTEMA DE CONEX√ÉO E RECONEX√ÉO
        // ===================================
        function initSocket() {
            GameState.socket = io({
                reconnection: true,
                reconnectionDelay: 1000,
                reconnectionAttempts: 5
            });

            const socket = GameState.socket;

            socket.on('connect', () => {
                console.log('‚úÖ Conectado ao servidor');
                GameState.isConnected = true;
                GameState.localPlayerId = socket.id;
                updateConnectionStatus(true);
                document.getElementById('lobby-status').innerText = 'Conectado! Aguardando outros jogadores...';
            });

            socket.on('disconnect', (reason) => {
                console.warn('‚ùå Desconectado:', reason);
                GameState.isConnected = false;
                updateConnectionStatus(false);
                document.getElementById('lobby-status').innerText = 'Desconectado do servidor. Tentando reconectar...';
            });

            socket.on('connect_error', (error) => {
                console.error('Erro de conex√£o:', error);
                updateConnectionStatus(false);
            });

            // ===================================
            // EVENTOS DO LOBBY
            // ===================================
            socket.on('updateSettings', (settings) => {
                if (!settings) return;
                GameState.settings = settings;
                document.getElementById('inp-speed').value = settings.speed;
                document.getElementById('disp-speed').innerText = settings.speed;
                document.getElementById('inp-wins').value = settings.winLimit;
                GameState.dropInterval = Math.max(50, 1000 - ((settings.speed - 1) * 45));
            });

            socket.on('updatePlayerList', (players) => {
                if (!players) return;
                GameState.players = players;
                const total = Object.keys(players).length;
                const ready = Object.values(players).filter(p => p.isReady).length;
                document.getElementById('lobby-status').innerText = `${ready} de ${total} jogadores prontos`;
            });

            // ===================================
            // EVENTOS DE JOGO
            // ===================================
            socket.on('startGame', (players) => {
                if (!players) return;
                console.log('üéÆ Iniciando jogo com jogadores:', Object.keys(players).length);
                startGame(players);
            });

            socket.on('startNextRound', () => {
                console.log('üîÑ Pr√≥ximo round iniciando...');
                if (GameState.isGameRunning) {
                    startRound();
                }
            });

            socket.on('newPlayer', (playerData) => {
                if (!playerData || !GameState.isGameRunning) return;
                console.log('‚ûï Novo jogador:', playerData.name);
                if (playerData.id !== socket.id && !GameState.opponents[playerData.id]) {
                    addOpponent(playerData.id, playerData);
                }
            });

            socket.on('playerLeft', (playerId) => {
                console.log('‚ûñ Jogador saiu:', playerId);
                removeOpponent(playerId);
            });

            socket.on('playerUpdated', (data) => {
                if (!data || !data.id || data.id === socket.id) return;
                updateOpponent(data);
            });

            socket.on('playerDied', (playerId) => {
                if (playerId === socket.id) return;
                console.log('üíÄ Jogador morreu:', playerId);
                markOpponentDead(playerId);
            });

            socket.on('receiveGarbage', (data) => {
                if (!data || !GameState.isGameRunning || GameState.isDead) return;
                console.log('üì¶ Recebendo lixo:', data.lines);
                receiveGarbage(data.lines);
            });

            socket.on('roundOver', (data) => {
                if (!data) return;
                console.log('üèÅ Round finalizado. Vencedor:', data.winnerName);
                handleRoundOver(data);
            });

            socket.on('resetToLobby', () => {
                console.log('üîô Retornando ao lobby');
                resetToLobby();
            });
        }

        function updateConnectionStatus(connected) {
            const status = document.getElementById('connection-status');
            if (connected) {
                status.className = 'status-connected';
                status.innerText = '‚óè Conectado';
            } else {
                status.className = 'status-disconnected';
                status.innerText = '‚óè Desconectado';
            }
        }

        // ===================================
        // SINTETIZADOR DE M√öSICA 8-BIT
        // ===================================
        class TetrisSynth {
            constructor() {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.isPlaying = false;
                this.tempo = 145;
                this.nextNoteTime = 0;
                this.noteIndex = 0;
                this.timerID = null;
                
                this.notes = {
                    'E5': 659.25, 'B4': 493.88, 'C5': 523.25, 'D5': 587.33, 'A4': 440.00,
                    'G#4': 415.30, 'G4': 392.00, 'F4': 349.23, 'E4': 329.63
                };

                this.melody = [
                    ['E5', 1], ['B4', 0.5], ['C5', 0.5], ['D5', 1], ['C5', 0.5], ['B4', 0.5],
                    ['A4', 1], ['A4', 0.5], ['C5', 0.5], ['E5', 1], ['D5', 0.5], ['C5', 0.5],
                    ['B4', 1.5], ['C5', 0.5], ['D5', 1], ['E5', 1],
                    ['C5', 1], ['A4', 1], ['A4', 1], [null, 1],
                    ['D5', 1.5], ['F4', 0.5], ['A4', 1], ['G4', 0.5], ['F4', 0.5],
                    ['E5', 1.5], ['C5', 0.5], ['E5', 1], ['D5', 0.5], ['C5', 0.5],
                    ['B4', 1], ['B4', 0.5], ['C5', 0.5], ['D5', 1], ['E5', 1],
                    ['C5', 1], ['A4', 1], ['A4', 1], [null, 1]
                ];
            }

            scheduleNote() {
                const secondsPerBeat = 60.0 / this.tempo;
                
                while (this.nextNoteTime < this.ctx.currentTime + 0.1) {
                    const note = this.melody[this.noteIndex];
                    
                    if (note[0]) {
                        const osc = this.ctx.createOscillator();
                        const gain = this.ctx.createGain();
                        
                        osc.type = 'square';
                        osc.frequency.value = this.notes[note[0]];
                        
                        gain.gain.value = 0.05;
                        gain.gain.exponentialRampToValueAtTime(0.001, this.nextNoteTime + (note[1] * secondsPerBeat));

                        osc.connect(gain);
                        gain.connect(this.ctx.destination);
                        
                        osc.start(this.nextNoteTime);
                        osc.stop(this.nextNoteTime + (note[1] * secondsPerBeat));
                    }

                    this.nextNoteTime += note[1] * secondsPerBeat;
                    this.noteIndex = (this.noteIndex + 1) % this.melody.length;
                }
                
                if (this.isPlaying) {
                    this.timerID = requestAnimationFrame(this.scheduleNote.bind(this));
                }
            }

            play() {
                if (this.ctx.state === 'suspended') this.ctx.resume();
                if (!this.isPlaying) {
                    this.isPlaying = true;
                    this.nextNoteTime = this.ctx.currentTime + 0.1;
                    this.scheduleNote();
                }
            }

            stop() {
                this.isPlaying = false;
                if (this.timerID) cancelAnimationFrame(this.timerID);
            }
        }

        const musicSynth = new TetrisSynth();

        function toggleMusic() {
            const btnMusic = document.getElementById('btn-music');
            if (!musicSynth.isPlaying) {
                musicSynth.play();
                btnMusic.innerText = "üîä M√∫sica: ON";
                btnMusic.style.background = "#2ed573";
                btnMusic.style.color = "#000";
            } else {
                musicSynth.stop();
                btnMusic.innerText = "üîá M√∫sica: OFF";
                btnMusic.style.background = "#444";
                btnMusic.style.color = "#fff";
            }
        }

        document.body.addEventListener('click', () => {
            if (musicSynth.ctx.state === 'suspended') musicSynth.ctx.resume();
        }, { once: true });

        // ===================================
        // FUN√á√ïES DO LOBBY
        // ===================================
        function emitSettings() {
            if (!GameState.isConnected) return;
            const speed = parseInt(document.getElementById('inp-speed').value);
            const wins = parseInt(document.getElementById('inp-wins').value);
            document.getElementById('disp-speed').innerText = speed;
            GameState.socket.emit('changeSettings', { speed, winLimit: wins });
        }

        function toggleReady() {
            const nameInput = document.getElementById('inp-name');
            const name = nameInput.value.trim();
            
            if (!name) {
                alert("Por favor, digite um Nickname antes de come√ßar!");
                return;
            }

            if (!GameState.isConnected) {
                alert("Aguarde a conex√£o com o servidor!");
                return;
            }
            
            GameState.localName = name;
            GameState.isLocalReady = !GameState.isLocalReady;
            const btn = document.getElementById('btn-ready');
            
            if (GameState.isLocalReady) {
                btn.className = 'btn-ready is-ready';
                btn.innerText = "AGUARDANDO...";
                nameInput.disabled = true;
                if (musicSynth.ctx.state === 'suspended') musicSynth.ctx.resume();
            } else {
                btn.className = 'btn-ready not-ready';
                btn.innerText = "N√ÉO ESTOU PRONTO";
                nameInput.disabled = false;
            }
            
            GameState.socket.emit('playerReady', { state: GameState.isLocalReady, name: GameState.localName });
        }

        function requestReset() {
            if (confirm("Parar a partida e voltar todos para o Lobby?")) {
                GameState.socket.emit('requestReset');
            }
        }

        // ===================================
        // CLASSE RENDERIZADORA
        // ===================================
        const COLORS = [null,'#00f0f0','#f0a000','#0000f0','#f0f000','#00f000','#a000f0','#f00000','#555'];

        class TetrisRenderer {
            constructor(id, isLocal, name) {
                this.id = id;
                this.isLocal = isLocal;
                this.name = name;
                this.wins = 0;
                this.score = 0;
                
                this.element = document.createElement('div');
                this.element.className = isLocal ? 'player-card local' : 'player-card';
                this.element.innerHTML = `
                    <div class="name-tag">${name}</div>
                    <canvas width="240" height="400"></canvas>
                    <div class="stats-row">
                        <span>PTS: <span class="score-val">0</span></span>
                        <span>VIT: <span class="win-count">0</span></span>
                    </div>
                `;
                
                const gameArea = document.getElementById('game-area');
                if (isLocal) gameArea.prepend(this.element);
                else gameArea.appendChild(this.element);

                this.canvas = this.element.querySelector('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.ctx.scale(20, 20);
                
                this.elScore = this.element.querySelector('.score-val');
                this.elWins = this.element.querySelector('.win-count');
                
                this.arena = this.createMatrix(12, 20);
                this.player = { pos: { x: 0, y: 0 }, matrix: null };
            }

            createMatrix(w, h) {
                const m = [];
                while (h--) m.push(new Array(w).fill(0));
                return m;
            }

            updateScore(score) {
                this.score = score;
                this.elScore.innerText = score;
            }

            updateWins(wins) {
                this.wins = wins;
                this.elWins.innerText = wins;
            }

            markDead() {
                this.element.classList.add('dead');
            }

            revive() {
                this.element.classList.remove('dead');
            }

            draw() {
                // Fundo
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(0, 0, 12, 20);
                
                // Arena
                this.drawMatrix(this.arena, { x: 0, y: 0 });
                
                // Pe√ßa + Ghost (somente para jogador local)
                if (this.isLocal && !GameState.isDead && this.player.matrix) {
                    this.drawGhost();
                    this.drawMatrix(this.player.matrix, this.player.pos);
                }
            }

            drawMatrix(matrix, offset) {
                matrix.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value !== 0) {
                            this.ctx.fillStyle = COLORS[value];
                            this.ctx.fillRect(x + offset.x, y + offset.y, 1, 1);
                            this.ctx.lineWidth = 0.05;
                            this.ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                            this.ctx.strokeRect(x + offset.x, y + offset.y, 1, 1);
                        }
                    });
                });
            }

            drawGhost() {
                const ghost = { ...this.player.pos };
                while (!this.collide({ ...this.player, pos: ghost })) ghost.y++;
                ghost.y--;
                
                this.player.matrix.forEach((row, y) => {
                    row.forEach((v, x) => {
                        if (v !== 0) {
                            this.ctx.fillStyle = 'rgba(255,255,255,0.15)';
                            this.ctx.fillRect(x + ghost.x, y + ghost.y, 1, 1);
                            this.ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                            this.ctx.lineWidth = 0.05;
                            this.ctx.strokeRect(x + ghost.x, y + ghost.y, 1, 1);
                        }
                    });
                });
            }

            collide(player) {
                const [m, o] = [player.matrix, player.pos];
                for (let y = 0; y < m.length; ++y) {
                    for (let x = 0; x < m[y].length; ++x) {
                        if (m[y][x] !== 0 && 
                            (this.arena[y + o.y] === undefined ||
                             this.arena[y + o.y][x + o.x] === undefined ||
                             this.arena[y + o.y][x + o.x] !== 0)) {
                            return true;
                        }
                    }
                }
                return false;
            }

            destroy() {
                this.element.remove();
            }
        }

        // ===================================
        // L√ìGICA DO TETRIS
        // ===================================
        const PIECES = {
            'I': [[0,1,0,0],[0,1,0,0],[0,1,0,0],[0,1,0,0]],
            'L': [[0,2,0],[0,2,0],[0,2,2]],
            'J': [[0,3,0],[0,3,0],[3,3,0]],
            'O': [[4,4],[4,4]],
            'Z': [[5,5,0],[0,5,5],[0,0,0]],
            'S': [[0,6,6],[6,6,0],[0,0,0]],
            'T': [[0,7,0],[7,7,7],[0,0,0]]
        };

        function createNewPiece() {
            const pieces = 'ILJOTSZ';
            const type = pieces[Math.floor(Math.random() * pieces.length)];
            return JSON.parse(JSON.stringify(PIECES[type])); // Deep copy
        }

        function resetPlayer() {
            if (!GameState.localGame) return;

            const piece = createNewPiece();
            GameState.localGame.player.matrix = piece;
            GameState.localGame.player.pos.y = 0;
            GameState.localGame.player.pos.x = Math.floor((12 - piece[0].length) / 2);
            
            // Verifica game over instant√¢neo
            if (GameState.localGame.collide(GameState.localGame.player)) {
                playerDie();
            } else {
                emitUpdate();
            }
        }

        function playerDie() {
            console.log('üíÄ Jogador local morreu');
            GameState.isDead = true;
            GameState.localGame.markDead();
            GameState.socket.emit('playerGameOver');
        }

        function rotate(matrix, dir) {
            // Transpor
            for (let y = 0; y < matrix.length; ++y) {
                for (let x = 0; x < y; ++x) {
                    [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
                }
            }
            // Reverter
            if (dir > 0) matrix.forEach(row => row.reverse());
            else matrix.reverse();
        }

        function merge() {
            const game = GameState.localGame;
            game.player.matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        const arenaY = y + game.player.pos.y;
                        const arenaX = x + game.player.pos.x;
                        if (arenaY >= 0 && arenaY < game.arena.length &&
                            arenaX >= 0 && arenaX < game.arena[0].length) {
                            game.arena[arenaY][arenaX] = value;
                        }
                    }
                });
            });
            emitUpdate();
        }

        function arenaSweep() {
            const game = GameState.localGame;
            let linesCleared = 0;
            
            outer: for (let y = game.arena.length - 1; y > 0; --y) {
                for (let x = 0; x < game.arena[y].length; ++x) {
                    if (game.arena[y][x] === 0) continue outer;
                }
                
                const row = game.arena.splice(y, 1)[0].fill(0);
                game.arena.unshift(row);
                ++y;
                linesCleared++;
            }
            
            if (linesCleared > 0) {
                game.updateScore(game.score + linesCleared * 100);
                GameState.socket.emit('sendAttack', linesCleared);
                console.log(`‚ú® ${linesCleared} linha(s) eliminada(s)`);
            }
        }

        // ===================================
        // CONTROLES DO JOGADOR
        // ===================================
        function playerDrop() {
            if (GameState.isDead || !GameState.localGame) return;
            
            GameState.localGame.player.pos.y++;
            
            if (GameState.localGame.collide(GameState.localGame.player)) {
                GameState.localGame.player.pos.y--;
                merge();
                resetPlayer();
                arenaSweep();
            }
            
            GameState.dropCounter = 0;
            emitUpdate();
        }

        function playerMove(dir) {
            if (GameState.isDead || !GameState.localGame) return;
            
            GameState.localGame.player.pos.x += dir;
            
            if (GameState.localGame.collide(GameState.localGame.player)) {
                GameState.localGame.player.pos.x -= dir;
            }
            
            emitUpdate();
        }

        function playerRotate(dir) {
            if (GameState.isDead || !GameState.localGame) return;
            
            const pos = GameState.localGame.player.pos.x;
            let offset = 1;
            
            rotate(GameState.localGame.player.matrix, dir);
            
            while (GameState.localGame.collide(GameState.localGame.player)) {
                GameState.localGame.player.pos.x += offset;
                offset = -(offset + (offset > 0 ? 1 : -1));
                
                if (offset > GameState.localGame.player.matrix[0].length) {
                    rotate(GameState.localGame.player.matrix, -dir);
                    GameState.localGame.player.pos.x = pos;
                    return;
                }
            }
            
            emitUpdate();
        }

        function playerHardDrop() {
            if (GameState.isDead || !GameState.localGame) return;
            
            while (!GameState.localGame.collide(GameState.localGame.player)) {
                GameState.localGame.player.pos.y++;
            }
            
            GameState.localGame.player.pos.y--;
            merge();
            resetPlayer();
            arenaSweep();
            GameState.dropCounter = 0;
            emitUpdate();
        }

        // ===================================
        // NETWORKING COM THROTTLE
        // ===================================
        function emitUpdate() {
            if (!GameState.isConnected || !GameState.localGame) return;
            
            const now = Date.now();
            if (now - GameState.lastEmitTime < GameState.emitThrottle) return;
            GameState.lastEmitTime = now;
            
            const display = GameState.localGame.arena.map(r => [...r]);
            
            // Desenha pe√ßa atual na matriz
            if (GameState.localGame.player.matrix && !GameState.isDead) {
                GameState.localGame.player.matrix.forEach((r, y) => {
                    r.forEach((v, x) => {
                        const arenaY = y + GameState.localGame.player.pos.y;
                        const arenaX = x + GameState.localGame.player.pos.x;
                        if (v !== 0 && arenaY >= 0 && arenaY < display.length &&
                            arenaX >= 0 && arenaX < display[0].length) {
                            display[arenaY][arenaX] = v;
                        }
                    });
                });
            }
            
            GameState.socket.emit('playerMove', {
                matrix: display,
                score: GameState.localGame.score
            });
        }

        function receiveGarbage(lines) {
            if (!GameState.localGame || GameState.isDead) return;
            
            // Remove linhas do topo
            GameState.localGame.arena.splice(0, lines);
            
            // Adiciona lixo embaixo
            for (let i = 0; i < lines; i++) {
                GameState.localGame.arena.push(new Array(12).fill(8));
            }
            
            // Ajusta posi√ß√£o do jogador
            GameState.localGame.player.pos.y -= lines;
            
            if (GameState.localGame.player.pos.y < 0) {
                GameState.localGame.player.pos.y = 0;
            }
            
            // Verifica colis√£o ap√≥s receber lixo
            if (GameState.localGame.collide(GameState.localGame.player)) {
                playerDie();
            }
            
            emitUpdate();
        }

        // ===================================
        // GERENCIAMENTO DE OPONENTES
        // ===================================
        function addOpponent(id, data) {
            if (GameState.opponents[id]) return;
            
            const op = new TetrisRenderer(id, false, data.name || "Rival");
            if (data.matrix) op.arena = data.matrix;
            if (data.wins !== undefined) op.updateWins(data.wins);
            if (data.score !== undefined) op.updateScore(data.score);
            
            GameState.opponents[id] = op;
        }

        function removeOpponent(id) {
            if (GameState.opponents[id]) {
                GameState.opponents[id].destroy();
                delete GameState.opponents[id];
            }
        }

        function updateOpponent(data) {
            let op = GameState.opponents[data.id];
            
            if (!op) {
                addOpponent(data.id, data);
                op = GameState.opponents[data.id];
            }
            
            if (data.matrix) op.arena = data.matrix;
            if (data.score !== undefined) op.updateScore(data.score);
            if (data.wins !== undefined) op.updateWins(data.wins);
        }

        function markOpponentDead(id) {
            if (GameState.opponents[id]) {
                GameState.opponents[id].markDead();
            }
        }

        // ===================================
        // CONTROLE DE FLUXO DO JOGO
        // ===================================
        function startGame(players) {
            // Esconde lobby
            const lobbyScreen = document.getElementById('lobby-screen');
            lobbyScreen.style.opacity = 0;
            setTimeout(() => lobbyScreen.style.display = 'none', 300);
            
            // Esconde ranking
            document.getElementById('ranking-screen').style.display = 'none';
            
            // Mostra bot√£o de parar
            document.getElementById('btn-stop').style.display = 'block';
            
            // Limpa √°rea de jogo
            document.getElementById('game-area').innerHTML = '';
            
            // Reseta estado
            GameState.isGameRunning = true;
            GameState.opponents = {};
            
            // Cria tabuleiro local
            GameState.localGame = new TetrisRenderer(GameState.localPlayerId, true, GameState.localName);
            
            // Cria tabuleiros dos oponentes
            Object.values(players).forEach(p => {
                if (p.id !== GameState.localPlayerId) {
                    addOpponent(p.id, p);
                }
            });

            // Inicia round
            startRound();
            
            // Toca m√∫sica
            if (!musicSynth.isPlaying) toggleMusic();
        }

        function startRound() {
            GameState.isDead = false;
            
            if (GameState.localGame) {
                GameState.localGame.revive();
                GameState.localGame.arena = GameState.localGame.createMatrix(12, 20);
                resetPlayer();
            }
            
            update();
        }

        function handleRoundOver(data) {
            // Atualiza vit√≥rias
            if (data.winnerId === GameState.localPlayerId) {
                GameState.localGame.updateWins(data.wins);
            } else if (GameState.opponents[data.winnerId]) {
                GameState.opponents[data.winnerId].updateWins(data.wins);
            }

            // Se a partida acabou
            if (data.isMatchOver) {
                showRanking(data.players);
            }
        }

        function showRanking(playersData) {
            GameState.isGameRunning = false;
            document.getElementById('ranking-screen').style.display = 'block';
            document.getElementById('btn-stop').style.display = 'none';
            
            const tbody = document.getElementById('ranking-body');
            tbody.innerHTML = '';

            const ranking = Object.values(playersData).sort((a, b) => {
                if (b.wins !== a.wins) return b.wins - a.wins;
                return b.score - a.score;
            });

            ranking.forEach((p, index) => {
                const tr = document.createElement('tr');
                const rankClass = index === 0 ? 'rank-1' : (index === 1 ? 'rank-2' : (index === 2 ? 'rank-3' : ''));
                const displayName = p.id === GameState.localPlayerId ? `${p.name} (Voc√™)` : p.name;
                
                tr.innerHTML = `
                    <td class="${rankClass}">#${index + 1}</td>
                    <td>${displayName}</td>
                    <td style="color:#ffe600; font-weight:bold">${p.wins}</td>
                    <td>${p.score}</td>
                `;
                tbody.appendChild(tr);
            });
        }

        function resetToLobby() {
            GameState.isGameRunning = false;
            
            const lobbyScreen = document.getElementById('lobby-screen');
            lobbyScreen.style.display = 'flex';
            setTimeout(() => lobbyScreen.style.opacity = 1, 50);
            
            document.getElementById('ranking-screen').style.display = 'none';
            document.getElementById('btn-stop').style.display = 'none';
            
            GameState.isLocalReady = false;
            const btn = document.getElementById('btn-ready');
            btn.className = 'btn-ready not-ready';
            btn.innerText = "N√ÉO ESTOU PRONTO";
            document.getElementById('inp-name').disabled = false;
            
            if (musicSynth.isPlaying) toggleMusic();
            
            // Limpa tabuleiros
            if (GameState.localGame) {
                GameState.localGame.destroy();
                GameState.localGame = null;
            }
            
            Object.values(GameState.opponents).forEach(op => op.destroy());
            GameState.opponents = {};
        }

        // ===================================
        // LOOP PRINCIPAL
        // ===================================
        GameState.dropCounter = 0;
        let lastTime = 0;

        function update(time = 0) {
            if (!GameState.isGameRunning) return;
            
            const deltaTime = time - lastTime;
            lastTime = time;
            
            if (!GameState.isDead && GameState.localGame) {
                GameState.dropCounter += deltaTime;
                if (GameState.dropCounter > GameState.dropInterval) {
                    playerDrop();
                }
            }
            
            if (GameState.localGame) GameState.localGame.draw();
            Object.values(GameState.opponents).forEach(op => op.draw());
            
            requestAnimationFrame(update);
        }

        // ===================================
        // INPUT DO TECLADO
        // ===================================
        document.addEventListener('keydown', event => {
            if (!GameState.isGameRunning || GameState.isDead) return;
            
            switch(event.keyCode) {
                case 37: // Esquerda
                    playerMove(-1);
                    break;
                case 39: // Direita
                    playerMove(1);
                    break;
                case 40: // Baixo
                    playerDrop();
                    break;
                case 38: // Cima (Rotacionar)
                    playerRotate(1);
                    break;
                case 32: // Espa√ßo (Hard Drop)
                    event.preventDefault();
                    playerHardDrop();
                    break;
            }
        });

        // ===================================
        // INICIALIZA√á√ÉO
        // ===================================
        initSocket();
    </script>
</body>
</html>
